================================================================================
[001] Explore Differences Between the var and let Keywords
[002] Compare Scopes of the var and let Keywords
[003] Declare a Read-Only Variable with the const Keyword
[004] Mutate an Array Declared with const
[005] Prevent Object Mutation
[006] Use Arrow Functions to Write Concise Anonymous Functions
[007] Write Arrow Functions with Parameters
[008] Set Default Parameters for Your Functions
[009] Use the Rest Parameter with Function Parameters
[010] Use the Spread Operator to Evaluate Arrays In-Place
[011] Use Destructuring Assignment to Extract Values from Objects
[012] Use Destructuring Assignment to Assign Variables from Objects
[013] Use Destructuring Assignment to Assign Variables from Nested Objects
[014] Use Destructuring Assignment to Assign Variables from Arrays
[015] Use Destructuring Assignment with the Rest Parameter to Reassign Array Elements
[016] Use Destructuring Assignment to Pass an Object as a Function's Parameters
[017] Create Strings using Template Literals
[018] Write Concise Object Literal Declarations Using Object Property Shorthand
[019] Write Concise Declarative Functions with ES6
[020] Use class Syntax to Define a Constructor Function
[021] Use getters and setters to Control Access to an Object
[022] Create a Module Script
[023] Use export to Share a Code Block
[024] Reuse JavaScript Code Using import
[025] Use * to Import Everything from a File
[026] Create an Export Fallback with export default
[027] Import a Default Export
[028] Create a JavaScript Promise
[029] Complete a Promise with resolve and reject
[030] Handle a Fulfilled Promise with then
[031] Handle a Rejected Promise with catch
[X01] [Promise] 同期処理と非同期処理の速度比較
[X02] [Promise] 非同期処理間の処理の順番
[X03] [Promise] 非同期処理のコールバック内で次の非同期処理を呼び出す
[X04] [Promise] オブジェクト「Promise」の処理結果をメソッド「then」で制御する(1)
[X05] [Promise] オブジェクト「Promise」の処理結果をメソッド「then」で制御する(2)
[X06] [Promise] メソッド「then」内部のエラー処理をメソッド「catch」に移動(1)
[X07] [Promise] メソッド「then」内部のエラー処理をメソッド「catch」に移動(2)
[X08] [Promise] オブジェクト「Promise」で非同期処理を順番通りに実行
[X09] [Promise] 途中で失敗したらメソッド「catch」までのメソッド「then」の処理はスキップ
[X10] [Promise] 人為的に例外発生させてもメソッド「catch」までのメソッド「then」の処理はスキップ
[X11] [Promise] 非同期処理の並列実行(1)
[X12] [Promise] 非同期処理の並列実行(2)
[X13] [Promise] キーワード「async」と「await」で記述を簡略化
================================================================================
[001]
  Explore Differences Between the var and let Keywords
  
[内容]
  変数定義
    キーワード「var」=> 変数の再定義で上書き可能
    キーワード「let」=> 変数の再定義で構文エラー
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // キーワード「var」=> 再定義扱いになり上書き可能
    var myVar1 = '東京';  // エラー無し
    var myVar1 = '埼玉';  // エラー無し
    
    // キーワード「let」=> 構文エラー
    let myVar2 = '長野';  // エラー無し
    let myVar2 = '山梨';  // SyntaxError: redeclaration of let myVar2
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[002]
  Compare Scopes of the var and let Keywords
  
[内容]
  構文「for」の制御変数
    キーワード「var」=> グローバル変数
    キーワード「let」=> ローカル変数
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // 変数定義と初期化
    let sum1 = 0;
    let sum2 = 0;
    
    // キーワード「var」と「let」
    for (var idx1 = 0; idx1 < 3; idx1++) sum1 += idx1;
    for (let idx2 = 0; idx2 < 3; idx2++) sum2 += idx2;
    
    // 出力
    console.log(idx1);  // 3
    console.log(idx2);  // ReferenceError: idx2 is not defined
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[003]
  Declare a Read-Only Variable with the const Keyword
  
[内容]
  キーワード「const」=> 変数を定数(読取専用)化
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // キーワード「const」
    const myVar1 = 100;
    const myVar2 = 200;
    
    // 定数を更新
    myVar1 = 'AA';  // TypeError: invalid assignment to const 'myVar1'
    myVar2 = 3000;  // TypeError: invalid assignment to const 'myVar2'
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[004]
  Mutate an Array Declared with const
  
[内容]
  キーワード「const」=> 配列を定数(読取専用)化
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // キーワード「const」
    const myArr1 = [111, 222, 333];
    const myArr2 = ['A', 'B', 'C'];
    
    // 個別要素の変更はOK
    myArr1[0] = 999;
    myArr2[0] = 'Z';
    
    // 全要素の変更はNG
    myArr1 = [444, 555, 666];  // TypeError: invalid assignment to const 'myArr1'
    myArr2 = ['D', 'E', 'F'];  // TypeError: invalid assignment to const 'myArr2'
    
    // 出力
    console.log(myArr1);
    console.log(myArr2);
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[005]
  Prevent Object Mutation
  
[内容]
  オブジェクト保護「Object.freeze」
    プロパティの更新 => 不可
    プロパティの削除 => 不可
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // オブジェクト
    let OBJ = {
      key1: 100,
      key2: 200,
      key3: 300
    };
    
    // オブジェクトの保護
    Object.freeze(OBJ);
    
    // オブジェクトの保護でプロパティの更新は不可
    OBJ.key1 = 101;
    
    // オブジェクトの保護でプロパティの削除は不可
    delete OBJ.key1;
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[006]
  Use Arrow Functions to Write Concise Anonymous Functions
  
[内容]
  アロー関数(1)
    関数の記述を簡略化
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // 通常の関数
    function myFunc1() {
      return 'Hello World';
    }
    
    // アロー関数
    const myFunc2 = () => {
      return 'Hello World';
    }
    
    // 更に省略可
    const myFunc3 = () => 'Hello World';
    
    // 出力
    console.log(myFunc1());  // Hello World
    console.log(myFunc2());  // Hello World
    console.log(myFunc3());  // Hello World
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[007]
  Write Arrow Functions with Parameters
  
[内容]
  アロー関数(2)
    関数の記述を簡略化
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // 関数定義
    const myFunc1 = (P1) => {
      return 'Hello ' + P1;
    }
    
    // 引数一個なら括弧を省略可
    const myFunc2 = P1 => {
      return 'Hello ' + P1;
    }
    
    // 出力
    console.log(myFunc1('AAA'));  // Hello AAA
    console.log(myFunc2('AAA'));  // Hello AAA
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[008]
  Set Default Parameters for Your Functions
  
[内容]
  関数パラメータのデフォルト値
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // 関数定義
    const myFunc = (P1 = 'AAA') => 'Hello ' + P1;
    
    // 出力
    console.log(myFunc());       // Hello AAA
    console.log(myFunc('BBB'));  // Hello BBB
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[009]
  Use the Rest Parameter with Function Parameters
  
[内容]
  関数パラメータを可変長引数で表現する
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // 関数定義
    const myFunc = (...ARR) => {
      let RET = [];
      for (let i = 0; i < ARR.length; i++) RET.push(ARR[i]);
      return RET;
    }
    
    // 出力
    console.log(myFunc(1, 2));        // [1, 2]
    console.log(myFunc(1, 2, 3));     // [1, 2, 3]
    console.log(myFunc(1, 2, 3, 4));  // [1, 2, 3, 4]
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[010]
  Use the Spread Operator to Evaluate Arrays In-Place
  
[内容]
  スプレッド構文
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // 変数定義と初期化
    let ARR1 = [1, 2];
    let ARR2 = [...ARR1, 3, 4];
    
    // 出力
    console.log(ARR1);  // [1, 2]
    console.log(ARR2);  // [1, 2, 3, 4]
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[011]
  Use Destructuring Assignment to Extract Values from Objects
  
[内容]
  オブジェクトからの分割代入
    オブジェクト内のプロパティ値を複数の変数に保存
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // オブジェクト
    let OBJ = {
      key1: 300,
      key2: 400,
      key3: 500
    }
    
    // オブジェクトからの分割代入
    let { key1: V1, key2: V2, key3: V3 } = OBJ ;
    
    // 出力
    console.log(V1);  // 300
    console.log(V2);  // 400
    console.log(V3);  // 500
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[012]
  Use Destructuring Assignment to Assign Variables from Objects
  
[内容]
  オブジェクトからの分割代入
    別名の変数に保存
  
[確認]
  // 上記「011」を参照
  
================================================================================
[013]
  Use Destructuring Assignment to Assign Variables from Nested Objects
  
[内容]
  オブジェクトからの分割代入
    オブジェクト内部のオブジェクト群を変数に保存
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // オブジェクト
    let OBJ = {
      key1: 300,
      key2: 400,
      key3: 500,
      arr1: [ { key4: 100, key5: 111 }, { key4: 200, key5: 211 }, { key4: 300, key5: 311 } ],
      arr2: [ { key6: 'A', key7: 'B' }, { key6: 'C', key7: 'D' }, { key6: 'E', key7: 'F' } ]
    }
    
    // オブジェクト内のオブジェクト群を変数に保存
    let { arr1: ARR1, arr2: ARR2 } = OBJ;
    
    // 出力
    console.log(ARR1);
    console.log(ARR2);
  
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[014]
  Use Destructuring Assignment to Assign Variables from Arrays
  
[内容]
  配列からの分割代入
    複数の変数へ分割代入
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // 変数定義と初期化
    let V1;
    let V2;
    
    // 先頭から一番目と四番目の要素を変数に代入
    [V1,,, V2] = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    
    // 出力
    console.log(V1);  // 1
    console.log(V2);  // 9
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[015]
  Use Destructuring Assignment with the Rest Parameter to Reassign Array Elements
  
[内容]
  配列からの分割代入
    その他の要素を構文「...変数」で表現
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // 変数定義と初期化
    let var1;
    let var2;
    let rest;
    
    // 先頭から一番目と二番目の要素を変数に代入、残りの要素は「...変数」の変数に代入
    [var1, var2, ...rest] = [1, 2, 3, 4, 5]
    
    // 出力
    console.log(var1);  // 1
    console.log(var2);  // 2
    console.log(rest);  // [3, 4, 5]
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[016]
  Use Destructuring Assignment to Pass an Object as a Function's Parameters
  
[内容]
  関数の引数にオブジェクト指定
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // オブジェクト
    let OBJ = {
      key1: 3,
      key2: 4,
      key3: 5,
    }
    
    // 関数定義
    const Func = (P1) => P1.key1 * P1.key2 / 2;
    
    // 出力
    console.log(Func(OBJ));  // 6
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[017]
  Create Strings using Template Literals
  
[内容]
  テンプレート文字列「`文字列 ${変数} 文字列`」
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // オブジェクト
    let OBJ = {
      key1: 300,
      key2: 400,
      key3: 500
    }
    
    // オブジェクトの各プロパティ名を取得
    let ARR = Object.keys(OBJ);
    
    // オブジェクトの各プロパティ値を出力
    for (let i = 0; i < ARR.length; i++) console.log(`${ARR[i]}: ${OBJ[ARR[i]]}`);
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[018]
  Write Concise Object Literal Declarations Using Object Property Shorthand
  
[内容]
  オブジェクトのプロパティをショートハンドで記述
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // オブジェクトのプロパティ
    let key1 = 300;
    let key2 = 400;
    let key3 = 500;
    
    // オブジェクトのプロパティをショートハンドで記述
    let OBJ = {
      key1,
      key2,
      key3
    }
    
    // 出力
    console.log(OBJ.key1) ;  // 300
    console.log(OBJ.key2) ;  // 400
    console.log(OBJ.key3) ;  // 500
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[019]
  Write Concise Declarative Functions with ES6
  
[内容]
  オブジェクト内の関数の簡潔な記述
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // ES5 オブジェクト内の関数の記述
    let OBJ1 = {
      key1: 3,
      key2: 4,
      key3: 5,
      func: function() { return this.key1 * this.key2 / 2 ; }
    }
    
    // ES6 オブジェクト内の関数の記述
    let OBJ2 = {
      key1: 3,
      key2: 4,
      key3: 5,
      func() { return this.key1 * this.key2 / 2 ; }
    }
    
    // 出力
    console.log(OBJ1.func()) ;  // 6
    console.log(OBJ2.func()) ;  // 6
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[020]
  Use class Syntax to Define a Constructor Function
  
[内容]
  構文「class」でクラス定義およびオブジェクト作成
    内部プロパティを「ゲッター」と「セッター」で制御
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // クラス定義(ES6) => クラス名の頭文字は大文字が慣例
    class Person {
      constructor(name) {
        this._name = name;
      }
      getName() {
        return this._name;
      }
      setName(name) {
        this._name = name;
      }
    }
    
    // オブジェクト作成
    const P1 = new Person('上杉謙信');
    const P2 = new Person('武田信玄');
    
    // 内部プロパティへ直接にアクセス
    console.log(P1._name);
    console.log(P2._name);
    
    // 内部プロパティへ「ゲッター」を通してアクセス
    console.log(P1.getName());
    console.log(P2.getName());
    
    // 内部プロパティを「セッター」を通して更新
    P1.setName('上杉景勝');
    P2.setName('武田勝頼');
    
    // 内部プロパティへ「ゲッター」を通してアクセス
    console.log(P1.getName());
    console.log(P2.getName());
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[021]
  Use getters and setters to Control Access to an Object
  
[内容]
  構文「class」でクラス定義およびオブジェクト作成
    内部プロパティを「ゲッター」と「セッター」ではなく「プロパティ」で制御
  
[確認]
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script>
    
    // クラス定義(ES6) => クラス名の頭文字は大文字が慣例
    class Person {
      constructor(name) {
        this._name = name;
      }
      get name() {
        return this._name;
      }
      set name(name) {
        this._name = name;
      }
    }
    
    // オブジェクト作成
    const P1 = new Person('上杉謙信');
    const P2 = new Person('武田信玄');
    
    // 内部プロパティの値を「プロパティ」から取得
    console.log(P1.name);
    console.log(P2.name);
    
    // 内部プロパティの値を「プロパティ」を通して更新
    P1.name = '上杉景勝';
    P2.name = '武田勝頼';
    
    // 内部プロパティの値を「プロパティ」から取得
    console.log(P1.name);
    console.log(P2.name);
    
  </script>
  
  </body>
  </html>
  --------------------------------------------------
  
  # firefox
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[022]
  Create a Module Script
  
[内容]
  モジュール化(1)
    最初に「HTMLファイル」を作成
  
[確認]
  # cd $HOME
  # systemctl start httpd
  
  コマンドの実行結果
  --------------------------------------------------
  (ローカルで「Webサーバー」を起動)
  --------------------------------------------------
  
  # cd /var/www/html
  # vi sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  <!doctype html>
  <html lang="ja">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <title>SAMPLE</title>
  </head>
  <body>
  
  <!-- HTML --->
  <main></main>
  
  <!-- CSS --->
  <style></style>
  
  <!-- JS --->
  <script type='module' src='sample.js'></script>
  
  </body>
  </html>
  --------------------------------------------------
  
  以下の手順に続く
  
================================================================================
[023]
  Use export to Share a Code Block
  
[内容]
  モジュール化(2)
    モジュール作成 => 後に作成する「JSスクリプト」から呼び出される
  
[確認]
  # cd /var/www/html/mod
  # vi mod01.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 関数 + 名前付きエクスポート
  export const myAdd1 = (x, y) => x + y;
  export const mySub1 = (x, y) => x - y;
  export const myMul1 = (x, y) => x * y;
  export const myDiv1 = (x, y) => x / y;
  --------------------------------------------------
  
  # cd /var/www/html/mod
  # vi mod02.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 関数
  const myAdd2 = (x, y) => x + y;
  const mySub2 = (x, y) => x - y;
  const myMul2 = (x, y) => x * y;
  const myDiv2 = (x, y) => x / y;
  
  // 名前付きエクスポート + 別名
  export {myAdd2 as add2, mySub2 as sub2, myMul2 as mul2, myDiv2 as div2};
  --------------------------------------------------
  
  以下の手順に続く
  
================================================================================
[024]
  Reuse JavaScript Code Using import
  
[内容]
  モジュール化(3)
    各モジュールを呼び出す「JSスクリプト」を作成
  
[確認]
  # cd /var/www/html
  # vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 名前付きエクスポートのインポート + 別名
  import { myAdd1 as add1, mySub1 as sub1 } from './mod/mod01.js';
  
  // 名前付きエクスポートのインポート
  import { add2, sub2 } from './mod/mod02.js';
  
  // インポート関数を使用
  console.log(add1(22, 11));  // 33
  console.log(add2(22, 11));  // 33
  
  // インポート関数を使用
  console.log(sub1(22, 11));  // 11
  console.log(sub2(22, 11));  // 11
  --------------------------------------------------
  
  # (ブラウザ起動)
  # http://localhost/sample.html
  
  コマンドの実行結果
  --------------------------------------------------
  (省略)
  --------------------------------------------------
  
  以下の手順に続く
  
================================================================================
[025]
  Use * to Import Everything from a File
  
[内容]
  モジュール化(4)
    全関数をインポート
  
[確認]
  # cd /var/www/html/mod
  # vi mod01.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 関数 + 名前付きエクスポート
  export const add1 = (x, y) => x + y;
  export const sub1 = (x, y) => x - y;
  export const mul1 = (x, y) => x * y;
  export const div1 = (x, y) => x / y;
  --------------------------------------------------
  
  # cd /var/www/html/mod
  # vi mod02.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 関数
  const add2 = (x, y) => x + y;
  const sub2 = (x, y) => x - y;
  const mul2 = (x, y) => x * y;
  const div2 = (x, y) => x / y;
  
  // 名前付きエクスポート
  export {add2, sub2, mul2, div2};
  --------------------------------------------------
  
  # cd /var/www/html
  # vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 名前付きエクスポートの全インポート + 別名
  import * as Mod01 from './mod01.js';
  import * as Mod02 from './mod02.js';
  
  // インポート関数を使用
  console.log(Mod01.add1(22, 11));  // 33
  console.log(Mod02.add2(22, 11));  // 33
  
  // インポート関数を使用
  console.log(Mod01.sub1(22, 11));  // 11
  console.log(Mod02.sub2(22, 11));  // 11
  --------------------------------------------------
  
  以下の手順に続く
  
================================================================================
[026]
  Create an Export Fallback with export default
  
[内容]
  モジュール化(5)
    モジュール内のクラスをデフォルトエクスポート指定
  
[確認]
  # cd /var/www/html/mod
  # vi mod03.js
  
  コマンドの実行結果
  --------------------------------------------------
  // デフォルトエクスポート => クラス名は無名
  export default class {
    constructor(name) {
      this._name = name;
    }
    get name() {
      return this._name;
    }
    set name(name) {
      this._name = name;
    }
  }
  --------------------------------------------------
  
  # cd /var/www/html
  # vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // デフォルトエクスポートのインポート
  import Person from './mod/mod03.js';
  
  // オブジェクト生成
  let P1 = new Person('上杉謙信');
  let P2 = new Person('武田信玄');
  
  // 内部プロパティ確認
  console.log(P1.name);  // 上杉謙信
  console.log(P2.name);  // 武田信玄
  
  // 内部プロパティ更新
  P1.name = '上杉景勝';
  P2.name = '武田勝頼';
  
  // 内部プロパティ確認
  console.log(P1.name);  // 上杉景勝
  console.log(P2.name);  // 武田勝頼
  --------------------------------------------------
  
  以下の手順に続く
  
================================================================================
[027]
  Import a Default Export
  
[内容]
  モジュール化(6)
    モジュール内のデフォルトエクスポート指定された関数をインポート
  
[確認]
  # cd /var/www/html/mod
  # vi mod01.js
  
  コマンドの実行結果
  --------------------------------------------------
  // デフォルトエクスポート指定時に関数名を付けるとエラー
  export default function(x, y) { return x + y; }  // add1
  export const sub1 = (x, y) => x - y;
  export const mul1 = (x, y) => x * y;
  export const div1 = (x, y) => x / y;
  --------------------------------------------------
  
  # cd /var/www/html/mod
  # vi mod02.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 関数「add2」をデフォルトエクスポートする
  const add2 = (x, y) => x + y;
  const sub2 = (x, y) => x - y;
  const mul2 = (x, y) => x * y;
  const div2 = (x, y) => x / y;
  
  // デフォルトエクスポート + 名前付きエクスポート
  export {add2 as default, sub2, mul2, div2};
  --------------------------------------------------
  
  # cd /var/www/html
  # vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // デフォルトエクスポートのインポート
  import ADD1 from 'mod01.js';
  import ADD2 from 'mod02.js';
  
  // インポート関数
  console.log(ADD1(22, 11));  // 33
  console.log(ADD2(22, 11));  // 33
  --------------------------------------------------
  
  これにて「モジュール化」は終了する
  
================================================================================
[028]
  Create a JavaScript Promise
  
[内容]
  オブジェクト「Promise」を作成
  
[確認]
  // 下記「X01」から「X13」までを参照
  
================================================================================
[029]
  Complete a Promise with resolve and reject
  
[内容]
  オブジェクト「Promise」は「成功」か「失敗」で完了する
  
[確認]
  // 下記「X01」から「X13」までを参照
  
================================================================================
[030]
  Handle a Fulfilled Promise with then
  
[内容]
  処理成功のパターン
  
[確認]
  // 下記「X01」から「X13」までを参照
  
================================================================================
[031]
  Handle a Rejected Promise with catch
  
[内容]
  処理失敗のパターン
  
[確認]
  // 下記「X01」から「X13」までを参照
  
================================================================================
[X01]
  [Promise] 同期処理と非同期処理の速度比較
  
[内容]
  [Promise] 同期処理と非同期処理の速度比較
  
  非同期処理の例
    ディスクからファイルの内容を出力する
  
[確認]
  $ cd $HOME/sample05
  $ vi test01.txt
  
  コマンドの実行結果
  --------------------------------------------------
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ vi test02.txt
  
  コマンドの実行結果
  --------------------------------------------------
  1582年 本能寺の変
  1600年 関ヶ原の戦い
  1615年 大坂夏の陣
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ vi test03.txt
  
  コマンドの実行結果
  --------------------------------------------------
  1853年 ペリー来航
  1860年 桜田門外の変
  1867年 大政奉還
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  function Func() {
    
    // 同期処理1
    console.log('ファイル読取: 開始');
    
    // 非同期処理
    fs.readFile('test01.txt', { encoding: "utf8" }, (err, data) => {
      if (err) throw err;
      console.log(data);
    });
    
    // 同期処理2
    console.log('ファイル読取: 終了');
    
  }
  
  // 関数実行
  Func();
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 同期処理
  ファイル読取: 開始
  ファイル読取: 終了
  
  // 非同期処理
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X02]
  [Promise] 非同期処理間の処理の順番
  
[内容]
  [Promise] 非同期処理間の処理の順番
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  function Func() {
    
    // 非同期処理1
    fs.readFile('test01.txt', { encoding: "utf8" }, (err, data) => {
      if (err) throw err;
      console.log(data);
    });
    
    // 非同期処理2
    fs.readFile('test02.txt', { encoding: "utf8" }, (err, data) => {
      if (err) throw err;
      console.log(data);
    });
    
    // 非同期処理3
    fs.readFile('test03.txt', { encoding: "utf8" }, (err, data) => {
      if (err) throw err;
      console.log(data);
    });
    
  }
  
  // 関数実行
  Func();
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 処理順番は不安定
  
  1853年 ペリー来航
  1860年 桜田門外の変
  1867年 大政奉還
  
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  
  1582年 本能寺の変
  1600年 関ヶ原の戦い
  1615年 大坂夏の陣
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X03]
  [Promise] 非同期処理のコールバック内で次の非同期処理を呼び出す
  
[内容]
  [Promise] 非同期処理のコールバック内で次の非同期処理を呼び出す => 処理順番をコントロール(コールバック地獄)
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  function Func() {
    
    // コールバック内で更に非同期処理を呼び出す
    fs.readFile('test01.txt', { encoding: "utf8" }, (err, data) => {
      if (err) throw err;
      console.log(data);
      
      // コールバック内で更に非同期処理を呼び出す
      fs.readFile('test02.txt', { encoding: "utf8" }, (err, data) => {
        if (err) throw err;
        console.log(data);
        
        // コールバック内で更に非同期処理を呼び出す
        fs.readFile('test03.txt', { encoding: "utf8" }, (err, data) => {
          if (err) throw err;
          console.log(data);

        });
      });
    });
    
  }
  
  // 関数実行
  Func();
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 非同期処理の処理順番をコントロール可能 => ネストが深くなるとコールバック地獄
  
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  
  1582年 本能寺の変
  1600年 関ヶ原の戦い
  1615年 大坂夏の陣
  
  1853年 ペリー来航
  1860年 桜田門外の変
  1867年 大政奉還
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X04]
  [Promise] オブジェクト「Promise」の処理結果をメソッド「then」で制御する(1)
  
[内容]
  [Promise] オブジェクト「Promise」の処理結果をメソッド「then」で制御する(1)
  
  オブジェクト「Promise」
    ・三個(保留・成功・失敗)の内部状態を持つ
    ・初期状態は「保留」、一度でも「成功」または「失敗」になると以降の状態は変わらない
    ・コンストラクタ引数に関数オブジェクトを取る
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  // 非同期処理をオブジェクト「Promise」を返す形で書き直す
  function Func(FILE) {
    return new Promise((res, rej) => {
      fs.readFile(FILE, { encoding: "utf8" }, (err, doc) => {
        if (!err) {
          res(doc);  // 状態が「成功」になる => 引数「doc」はメソッド「then」の引数「doc」に渡される
        } else {
          rej(err);  // 状態が「失敗」になる => 引数「err」はメソッド「catch」の引数「err」に渡される
        }
      });
    })
  }
  
  // 実在するファイルを指定して、メソッド「then」内の「成功」のコード実行
  Func1('test01.txt')
  .then(
    (doc) => console.log(doc),  // 状態が「成功」の場合はこちらのコードが実行
    (err) => console.log(err)   // 状態が「失敗」の場合はこちらのコードが実行
  );
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 実在するファイルを指定して、メソッド「then」内の「成功」のコード実行
  
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X05]
  [Promise] オブジェクト「Promise」の処理結果をメソッド「then」で制御する(2)
  
[内容]
  [Promise] オブジェクト「Promise」の処理結果をメソッド「then」で制御する(2)
  
  オブジェクト「Promise」
    ・三個(保留・成功・失敗)の内部状態を持つ
    ・初期状態は「保留」、一度でも「成功」または「失敗」になると以降の状態は変わらない
    ・コンストラクタ引数に関数オブジェクトを取る
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  // 非同期処理をオブジェクト「Promise」を返す形で書き直す
  function Func(FILE) {
    return new Promise((res, rej) => {
      fs.readFile(FILE, { encoding: "utf8" }, (err, doc) => {
        if (!err) {
          res(doc);  // 状態が「成功」になる => 引数「doc」はメソッド「then」の引数「doc」に渡される
        } else {
          rej(err);  // 状態が「失敗」になる => 引数「err」はメソッド「catch」の引数「err」に渡される
        }
      });
    })
  }
  
  // 実在しないファイルを指定して、メソッド「then」内の「失敗」のコード実行
  Func('test99.txt')
  .then(
    (doc) => console.log(doc),  // 状態が「成功」の場合はこちらのコードが実行
    (err) => console.log(err)   // 状態が「失敗」の場合はこちらのコードが実行
  );
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 実在しないファイルを指定して、メソッド「then」内の「失敗」のコード実行
  
  [Error: ENOENT: no such file or directory, open './test99.txt'] {
    errno: -2,
    code: 'ENOENT',
    syscall: 'open',
    path: './test99.txt'
  }
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X06]
  [Promise] メソッド「then」内部のエラー処理をメソッド「catch」に移動(1)
  
[内容]
  [Promise] メソッド「then」内部のエラー処理をメソッド「catch」に移動(1)
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  // 非同期処理をオブジェクト「Promise」を返す形で書き直す
  function Func(FILE) {
    return new Promise((res, rej) => {
      fs.readFile(FILE, { encoding: "utf8" }, (err, doc) => {
        if (!err) {
          res(doc);  // 状態が「成功」になる => 引数「doc」はメソッド「then」の引数「doc」に渡される
        } else {
          rej(err);  // 状態が「失敗」になる => 引数「err」はメソッド「catch」の引数「err」に渡される
        }
      });
    })
  }
  
  // メソッド「then」内部のエラー処理をメソッド「catch」に移動
  Func('test01.txt')
  .then(
    (doc) => console.log(doc)
  )
  .catch(
    (err) => console.log(err)
  );
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // メソッド「then」内部のエラー処理をメソッド「catch」に移動
  
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X07]
  [Promise] メソッド「then」内部のエラー処理をメソッド「catch」に移動(2)
  
[内容]
  [Promise] メソッド「then」内部のエラー処理をメソッド「catch」に移動(2)
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  // 非同期処理をオブジェクト「Promise」を返す形で書き直す
  function Func(FILE) {
    return new Promise((res, rej) => {
      fs.readFile(FILE, { encoding: "utf8" }, (err, doc) => {
        if (!err) {
          res(doc);  // 状態が「成功」になる => 引数「doc」はメソッド「then」の引数「doc」に渡される
        } else {
          rej(err);  // 状態が「失敗」になる => 引数「err」はメソッド「catch」の引数「err」に渡される
        }
      });
    })
  }
  
  // メソッド「then」内部のエラー処理をメソッド「catch」に移動
  Func('test99.txt')
  .then(
    (doc) => console.log(doc)
  )
  .catch(
    (err) => console.log(err)
  );
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // メソッド「then」内部のエラー処理をメソッド「catch」に移動
  
  [Error: ENOENT: no such file or directory, open './test99.txt'] {
    errno: -2,
    code: 'ENOENT',
    syscall: 'open',
    path: './test99.txt'
  }
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X08]
  [Promise] オブジェクト「Promise」で非同期処理を順番通りに実行
  
[内容]
  [Promise] オブジェクト「Promise」で非同期処理を順番通りに実行
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  // 非同期処理をオブジェクト「Promise」を返す形で書き直す
  function Func(FILE) {
    return new Promise((res, rej) => {
      fs.readFile(FILE, { encoding: "utf8" }, (err, doc) => {
        if (!err) {
          res(doc);  // 状態が「成功」になる => 引数「doc」はメソッド「then」の引数「doc」に渡される
        } else {
          rej(err);  // 状態が「失敗」になる => 引数「err」はメソッド「catch」の引数「err」に渡される
        }
      });
    })
  }
  
  // 非同期処理を順番通りに実行
  Func('test01.txt')
  .then(
    (doc) => {
      console.log(doc);
      return Func('test02.txt');  // 次ファイル読込
    }
  )
  .then(
    (doc) => {
      console.log(doc);
      return Func('test03.txt');  // 次ファイル読込
    }
  )
  .then(
    (doc) => {
      console.log(doc);
      // ファイル読込終了
    }
  )
  .catch(
    (err) => {
      console.log(err);
      // エラー処理追加
    }
  );
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 非同期処理を順番通りに実行
  
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  
  1582年 本能寺の変
  1600年 関ヶ原の戦い
  1615年 大坂夏の陣
  
  1853年 ペリー来航
  1860年 桜田門外の変
  1867年 大政奉還
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X09]
  [Promise] 途中で失敗したらメソッド「catch」までのメソッド「then」の処理はスキップ
  
[内容]
  [Promise] 途中で失敗したらメソッド「catch」までのメソッド「then」の処理はスキップ
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  // 非同期処理をオブジェクト「Promise」を返す形で書き直す
  function Func(FILE) {
    return new Promise((res, rej) => {
      fs.readFile(FILE, { encoding: "utf8" }, (err, doc) => {
        if (!err) {
          res(doc);  // 状態が「成功」になる => 引数「doc」はメソッド「then」の引数「doc」に渡される
        } else {
          rej(err);  // 状態が「失敗」になる => 引数「err」はメソッド「catch」の引数「err」に渡される
        }
      });
    })
  }
  
  // 非同期処理を順番通りに実行
  Func('test01.txt')
  .then(
    (doc) => {
      console.log(doc);
      return Func('test99.txt');  // 実在しないファイル指定で失敗
    }
  )
  .then(
    (doc) => {
      console.log(doc);
      return Func('test03.txt');  // この処理はスキップされる
    }
  )
  .then(
    (doc) => {
      console.log(doc);
      // この処理はスキップされる
    }
  )
  .catch(
    (err) => {
      console.log(err);
      // エラー発生時に実行される
    }
  );
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 途中で失敗したらメソッド「catch」までのメソッド「then」の処理はスキップ
  
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  
  [Error: ENOENT: no such file or directory, open './test99.txt'] {
    errno: -2,
    code: 'ENOENT',
    syscall: 'open',
    path: './test99.txt'
  }
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X10]
  [Promise] 人為的に例外発生させてもメソッド「catch」までのメソッド「then」の処理はスキップ
  
[内容]
  [Promise] 人為的に例外発生させてもメソッド「catch」までのメソッド「then」の処理はスキップ
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  // 非同期処理をオブジェクト「Promise」を返す形で書き直す
  function Func(FILE) {
    return new Promise((res, rej) => {
      fs.readFile(FILE, { encoding: "utf8" }, (err, doc) => {
        if (!err) {
          res(doc);  // 状態が「成功」になる => 引数「doc」はメソッド「then」の引数「doc」に渡される
        } else {
          rej(err);  // 状態が「失敗」になる => 引数「err」はメソッド「catch」の引数「err」に渡される
        }
      });
    })
  }
  
  // 非同期処理を順番通りに実行
  Func('test01.txt')
  .then(
    (doc) => {
      console.log(doc);
      throw new Error('エラー発生');  // 人為的に例外発生
    }
  )
  .then(
    (doc) => {
      console.log(doc);
      return Func('test03.txt');  // この処理はスキップされる
    }
  )
  .then(
    (doc) => {
      console.log(doc);
      // この処理はスキップされる
    }
  )
  .catch(
    (err) => {
      console.log(err);
      // エラー処理追加
    }
  );
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // 人為的に例外発生させてもメソッド「catch」までのメソッド「then」の処理はスキップ
  
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  
  Error: エラー発生
    at /home/makoto/sample05/sample.js:19:42
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X11]
  [Promise] 非同期処理の並列実行(1)
  
[内容]
  [Promise] 非同期処理の並列実行(1)
  
[確認]
  $ cd $HOME/sample05
  $ vi file1.txt file2.txt file3.txt
  
  コマンドの実行結果
  --------------------------------------------------
  1. AAA
  2. BBB
  3. CCC
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  // ファイルの読込処理
  function Func(FILE) {
    return new Promise((res, rej) => {
      fs.readFile(FILE, { encoding: "utf8" }, (err, doc) => {
        if (!err) {
          res(doc);  // 状態が「成功」になる => 引数「doc」はメソッド「then」の引数「doc」に渡される
        } else {
          rej(err);  // 状態が「失敗」になる => 引数「err」はメソッド「catch」の引数「err」に渡される
        }
      });
    })
  }
  
  // 非同期処理を並列実行 => 最初の応答を使用する、最初に「失敗」が返ると全体で「失敗」となる
  Promise.race([Func('file1.txt'), Func('file2.txt'), Func('file3.txt')])
  .then(
    (doc) => console.log(doc)
  )
  .catch(
    (err) => console.log(err)
  );
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // ファイル読込を並列実行して、最初に応答したものを使用する
  
  1. AAA
  2. BBB
  3. CCC
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X12]
  [Promise] 非同期処理の並列実行(2)
  
[内容]
  [Promise] 非同期処理の並列実行(2)
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  // ファイルの読込処理
  function Func(FILE) {
    return new Promise((res, rej) => {
      fs.readFile(FILE, { encoding: "utf8" }, (err, doc) => {
        if (!err) {
          res(doc);  // 状態が「成功」になる => 引数「doc」はメソッド「then」の引数「doc」に渡される
        } else {
          rej(err);  // 状態が「失敗」になる => 引数「err」はメソッド「catch」の引数「err」に渡される
        }
      });
    })
  }
  
  // ファイル読込を並列実行して、全ファイル読込後に次処理に移行
  Promise.all([Func('test01.txt'), Func('test02.txt'), Func('test03.txt')])
  .then(
    ([doc1, doc2, doc3]) => {
      console.log(doc1);  // test01.txt => doc1
      console.log(doc2);  // test02.txt => doc2
      console.log(doc3);  // test03.txt => doc3
    }
  )
  .catch(
    (err) => console.log(err)
  );
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // ファイル読込を並列実行して、全ファイル読込完了後に次処理に移行
  
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  
  1582年 本能寺の変
  1600年 関ヶ原の戦い
  1615年 大坂夏の陣
  
  1853年 ペリー来航
  1860年 桜田門外の変
  1867年 大政奉還
  --------------------------------------------------
  
  確認完了!
  
================================================================================
[X13]
  [Promise] キーワード「async」と「await」で記述を簡略化
  
[内容]
  [Promise] キーワード「async」と「await」で記述を簡略化
  
[確認]
  $ cd $HOME/sample05
  $ vi sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // インポート
  const fs = require('fs');
  
  // ファイルの読込処理
  function Func(FILE) {
    return new Promise((res, rej) => {
      fs.readFile(FILE, { encoding: "utf8" }, (err, doc) => {
        if (!err) {
          res(doc);  // 状態が「成功」になる => 引数「doc」はメソッド「then」の引数「doc」に渡される
        } else {
          rej(err);  // 状態が「失敗」になる => 引数「err」はメソッド「catch」の引数「err」に渡される
        }
      });
    })
  }
  
  // キーワード「async」で非同期処理を内部に持つ関数を宣言
  async function Main() {
    try {
      let data1 = await Func('test01.txt');  // キーワード「await」で「Promise」の「正常」の値を取得
      let data2 = await Func('test02.txt');  // キーワード「await」で「Promise」の「正常」の値を取得
      let data3 = await Func('test03.txt');  // キーワード「await」で「Promise」の「正常」の値を取得
      console.log(data1);
      console.log(data2);
      console.log(data3);
    } catch (err) {
      console.log(err);
    }
  }
  
  // 非同期処理を順番に実行
  Main();
  --------------------------------------------------
  
  $ cd $HOME/sample05
  $ node sample.js
  
  コマンドの実行結果
  --------------------------------------------------
  // キーワード「async」と「await」を使用して非同期処理を呼び出す側の関数を簡略化する
  
  1274年 文永の役
  1281年 弘安の役
  1333年 鎌倉幕府滅亡
  
  1582年 本能寺の変
  1600年 関ヶ原の戦い
  1615年 大坂夏の陣
  
  1853年 ペリー来航
  1860年 桜田門外の変
  1867年 大政奉還
  --------------------------------------------------
  
  確認完了!
  
================================================================================
